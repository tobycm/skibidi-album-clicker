#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/spi.h"
#include "hardware/dma.h"
#include "JPEGDEC.h"
#include "image_data.h" // The file generated by your python script

// --- PIN CONFIGURATION (MATCH YOUR PCB!) ---
#define TFT_SPI_PORT spi0
#define TFT_PIN_SCK  2    // Check your KiCad! (Often GP2 or GP18)
#define TFT_PIN_MOSI 3    // Check your KiCad! (Often GP3 or GP19)
#define TFT_PIN_CS   1    // Chip Select
#define TFT_PIN_DC   0    // Data/Command
#define TFT_PIN_RST  26   // Reset (Or -1 if tied to 3.3V)
#define TFT_PIN_BL   27   // Backlight (Optional)

// --- DISPLAY CONSTANTS ---
#define TFT_WIDTH  240
#define TFT_HEIGHT 240

JPEGDEC jpeg;

// ==========================================
//   MINIMAL ST7789 DRIVER (High Speed)
// ==========================================

void tft_write_command(uint8_t cmd) {
    gpio_put(TFT_PIN_DC, 0); // Command mode
    gpio_put(TFT_PIN_CS, 0); // Select
    spi_write_blocking(TFT_SPI_PORT, &cmd, 1);
    gpio_put(TFT_PIN_CS, 1); // Deselect
}

void tft_write_data(uint8_t *data, size_t len) {
    gpio_put(TFT_PIN_DC, 1); // Data mode
    gpio_put(TFT_PIN_CS, 0); // Select
    spi_write_blocking(TFT_SPI_PORT, data, len);
    gpio_put(TFT_PIN_CS, 1); // Deselect
}

void tft_set_window(uint16_t x, uint16_t y, uint16_t w, uint16_t h) {
    uint8_t caset[] = {0, (uint8_t)x, 0, (uint8_t)(x + w - 1)};
    uint8_t raset[] = {0, (uint8_t)y, 0, (uint8_t)(y + h - 1)};
    
    tft_write_command(0x2A); // CASET
    tft_write_data(caset, 4);
    tft_write_command(0x2B); // RASET
    tft_write_data(raset, 4);
    tft_write_command(0x2C); // RAMWR
}

void tft_init() {
    spi_init(TFT_SPI_PORT, 62500000); // 62.5 MHz (Overclocked SPI for speed!)
    gpio_set_function(TFT_PIN_SCK, GPIO_FUNC_SPI);
    gpio_set_function(TFT_PIN_MOSI, GPIO_FUNC_SPI);

    gpio_init(TFT_PIN_CS); gpio_set_dir(TFT_PIN_CS, GPIO_OUT); gpio_put(TFT_PIN_CS, 1);
    gpio_init(TFT_PIN_DC); gpio_set_dir(TFT_PIN_DC, GPIO_OUT); gpio_put(TFT_PIN_DC, 1);
    
    if (TFT_PIN_RST != -1) {
        gpio_init(TFT_PIN_RST); gpio_set_dir(TFT_PIN_RST, GPIO_OUT);
        gpio_put(TFT_PIN_RST, 1); sleep_ms(100);
        gpio_put(TFT_PIN_RST, 0); sleep_ms(100);
        gpio_put(TFT_PIN_RST, 1); sleep_ms(200);
    }
    
    if (TFT_PIN_BL != -1) {
        gpio_init(TFT_PIN_BL); gpio_set_dir(TFT_PIN_BL, GPIO_OUT);
        gpio_put(TFT_PIN_BL, 1); // Turn Backlight ON
    }

    // ST7789 Init Commands
    tft_write_command(0x11); sleep_ms(120); // Sleep Out
    tft_write_command(0x3A); uint8_t color[] = {0x55}; tft_write_data(color, 1); // 16-bit color
    tft_write_command(0x36); uint8_t rot[] = {0x00}; tft_write_data(rot, 1); // Rotation
    tft_write_command(0x21); // Inversion On (IPS displays usually need this)
    tft_write_command(0x29); // Display On
}

// ==========================================
//   JPEG DRAWING CALLBACK
// ==========================================
// This function is called by the library for every 16x16 pixel block it decodes
int drawMCU(JPEGDRAW *pDraw) {
    // 1. Set the area on screen to match the block we just decoded
    tft_set_window(pDraw->x, pDraw->y, pDraw->iWidth, pDraw->iHeight);
    
    // 2. Prepare data mode
    gpio_put(TFT_PIN_DC, 1);
    gpio_put(TFT_PIN_CS, 0);
    
    // 3. Blast the pixels! (pDraw->pPixels is already in RGB565 format)
    spi_write_blocking(TFT_SPI_PORT, (uint8_t *)pDraw->pPixels, pDraw->iWidth * pDraw->iHeight * 2);
    
    gpio_put(TFT_PIN_CS, 1);
    return 1; // Continue drawing
}

// ==========================================
//   MAIN LOOP
// ==========================================
int main() {
    stdio_init_all();
    
    // 1. LATCH POWER (Critical for Soft-Latch Circuit)
    // Replace '0' with your N-MOSFET GPIO
    gpio_init(0); 
    gpio_set_dir(0, GPIO_OUT);
    gpio_put(0, 1); // HOLD POWER ON!

    // 2. Init Display
    tft_init();

    // 3. Clear Screen (Black)
    tft_set_window(0, 0, TFT_WIDTH, TFT_HEIGHT);
    // (Optional: loop to fill black if needed, usually starts black)

    while (true) {
        // Loop through all images in image_data.h
        for (int i = 0; i < total_images; i++) {
            
            // Open JPEG from Flash Memory
            if (jpeg.openFLASH((uint8_t *)image_list[i], image_sizes[i], drawMCU)) {
                
                // Decode (Starts calling drawMCU repeatedly)
                jpeg.setPixelType(RGB565_BIG_ENDIAN); // ST7789 expects Big Endian
                jpeg.decode(0, 0, 0);
                jpeg.close();
            }
            
            // Wait 3 seconds before next slide
            sleep_ms(3000);
        }
    }
}